-> Spring Boot is an approach to develop Spring Based applications
with minimal or less configurations.
Spring Boot Advantages(AAEERS)
-----------------------
1) Starter Poms
2) Auto Configuration
3) Embedded Servers
4) Acutators
5) Embedded Databases
6) Rapid Application Development
Spring Boot Dis-Advantages
---------------------------
-> Migrating Spring project into Spring Boot application is a
difficult task
Conclusion
----------
Spring Boot = (Spring Framework - XML Configuration ) + Auto Configuration  + Actuators + Embedded Servers
---------------------------------------------------------------------------------------------------------------------------------------------------------
-> We are creating our boot application using maven

-> We can see below folders in our maven based boot application
	
		src/main/java
			- Application.java
		src/main/resources
			- application.properties
		src/test/java
		Maven Dependencies
		target
		pom.xml

------------------------------------------------------------------------

-> When we create boot application one java class will be created by default that class is called as Start Class or main class.

-> Spring Boot application execution will begin from start class only.

-> Start class is the entry point for boot application execution.
-------------------------------------------------------------------------

@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
---------------------------------------------------------------------
-> From Boot start class we have to understand below 2 things very clearly

	1) @SpringBootApplication
	2) SpringApplication.run( ) method

-> The @SpringBootApplication annotation is equal to below 3 annotations

	1) @SpringBootConfiguration(sc)
	2) @EnableAutoConfiguration(eac)
	3) @ComponentScan(cs)

-> SpringApplication.run() method is used to bootstrap our spring boot application.

--------------------------------------------------------------------------------------------------------------------------------------------
-> SpringApplication.run(..) method performs bootstrapping of spring boot application.

Note: Bootstrapping means starting the application.

-> By using spring Boot we can create 3 types of applications

		1) Reactive Application

		2) Web Application

		3) Standalone application

-> At the time of creating boot project, if we don't select any dependency it will add 'spring-boot-starter' dependency by default. This will be considered as Standalone application.

-> At the time of creating boot project, if we select 'spring-boot-starter-web' dependency then it will be considered as 'SERVLET' based application.

-> At the time of creating boot project, if we select 
'spring-boot-starter-webflux' dependency then it will be considered as 'REACTIVE' based application.

Note: In SpringApplication class constructor logic is available to identify what type of project we have created ( deduceFromClassPath() );




-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> SpringApplication.run() method will start boot application execution process.

-> Below things are executing as part of run( ) method.

	-> It will identify type of the project
			- Reactive (webflux starter)
			- Web Servlet (web starter)
			- Default Standalone (boot starter)

	-> It will start stop watch to calculate time

	-> It will start listeners based on spring.factories file

	-> It will prepare environment (profiles it will load)

	-> It will print banner (we can customize banner)
	
	-> It will create IOC based on application type

	-> It will prepare & refresh application context

	-> It will stop the StopWatch and will calculate total time

	-> Call Runners

	-> It returns IOC container reference( ConfigurableAppCtxt )
-------------------------------------------------------------------------

	


What is Component Scanning?
-----------------------------
-> Programmer has to enable component scanning in spring framework

-> Programmer no need to enable component scanning in spring boot (by default it is enabled as part of Start class)
------------------------------------------------------------------------
-> Component Scanning is the process which is used to identify component classes (spring beans) available in the application.

-> Component Scanninng will work based on base package naming convention

---------------------------------------------------------------------------------------------------------------------------------------------------------

-> Component Scanning is the process of identifying spring bean classes available in the application.

-> In Spring Boot, Component Scanning is enabled by default.

-> In Spring Boot, Component Scanning will start from base package.

Note: The package which contains start class is called as base package.

-> Once Base package scanning is completed, it will search for sub packages of base package and will scan them.

Note: The packages which are starting with base package name are called as Sub packages of base package.

		in.ashokit  -----------------> Base package

		in.ashokit.beans ------> It is sub package for base pkg

		in.ashokit.dao -------> It is sub package for base pkg

		in.ashokit.service ------> It is sub pkg for base pkg

		in.ashokit.controller-----> It is sub pkg for base pkg

		in.ashokit.util-------> It is sub pkg for base pkg

		in.ashokit.service.admin-----> It is sub pkg for base pkg

		com.ashokit.model ----------> Not a sub package

-> If we have multiple packages with different names then we have to specify @ComponentScan annotation like below

----------------------------------------------------------------------------------
package in.ashokit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = { "com.ashokit", "in.ashokit", "" })
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext ctxt = SpringApplication.run(Application.class, args);
	}
}
----------------------------------------------------------------------------------
Note: It is highly recommended to follow base package naming convention so that we no need to write @ComponentScan manually.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
What is Spring Bean?
---------------------------------------------------------------------------------
-> The java class which is managing by IOC is called as Spring Bean.

-> To represent java class as Spring Bean we have below annotations

@Component
@Service
@Repository

@Controller
@RestController

@Configuration
@Bean (This is method level annotation)
-------------------------------------------------------------------------------------------------------------------------------------------------
-> To represent java class as configuration class we will use @Configuration annotation.

-> If we want to customize the object creation for a class then we will write method and will use @Bean annotation.

	Ex: Security Configuration
	    Kafka Producer Configuration
	    Kafka Consumer Configuration
            RestTemplate Configuration
	    WebClient Configuration
            Swagger Configuration etc...

-> If we want IOC container to create object for class then we will use below annotations at class level

		@Component
		@Service
		@Repository
----------------------------------------------------------------------------------
-> In Realtime we will develop our applications using Layered Architecture

		-> Presentation Layer (Ui)

		-> Web Layer (Controller Classes)

		-> Business Layer (Service classes)

		-> Persistence Layer (Dao/Repository classes)


-> User Interface Logic will be available in Presentation Layer

-> Web layer contains Controller classes which are responsible to handle request and response in web application.

-> Business Layer Contains Service classes which are responsible to execute business logic

  Ex: Sendng Email, Password Encryption & Decryption, Report Generation etc.

-> Persistence Layer Contains Dao/Repository classes which are responsible to communicate with database.
--------------------------------------------------------------------------------

-> Controller class method should call service class method so Service Class Object should be injected into controller class object.

-> Service class method should call dao method so dao class object should be injected into service class object.

----------------------------------------------------------------------------------
-> To inject one class object into another class object we will use @Autowired annotation

-> The process of injecting one class object into another class object is called as  ' Dependency Injection '.

-> In Spring / Spring Boot IOC container is responsible to perform this Dependency Injection.

-> @Autowired annotation we can use at below 3 places

		1) At Constructor Level (Constructor Injection)

		2) At Setter Level (Setter Injection)

		3) At Field Level (Field Injection)
---------------------------------------------------------------------------------
package in.ashokit.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDao {

	public boolean saveUser(String uname, String email, String pwd) {
		// logic to store in db
		System.out.println("Storing record in database....");
		return true;
	}
}
----------------------------------------------------------------------------------
package in.ashokit.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import in.ashokit.dao.UserDao;

@Service
public class UserService {

	private UserDao userDao = null;

	@Autowired
	public UserService(UserDao userDao) {
		this.userDao = userDao;
	}

	public void registerUser() {
		boolean isSaved = userDao.saveUser("ashok", "ashokitschool@gmail.com", "ashok@123");
		if (isSaved) {
			System.out.println("Record Saved....");
		} else {
			System.out.println("Failed to save....");
		}
	}
}
-------------------------------------------------------------------------------
package in.ashokit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

import in.ashokit.service.UserService;

@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		ConfigurableApplicationContext run = 
				SpringApplication.run(Application.class, args);

		UserService userService = run.getBean(UserService.class);

		userService.registerUser();
	}
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-> The process of injecting dependent bean object into target bean object through target bean constructor is called as 'Constructor Injection'.

-> To peform Constructor Injection, IOC will create Dependent Bean object first then it will create Target Bean object.

-> To inform IOC to perform Constructor Injection we will write @Autowired annotation at target class constructor.

Note: If target class is having only one parameterized constructor then writing @Autowired is optional.

----------------------------------------------------------------------------------
@Service
public class UserService {

	private UserDao userDao;

	@Autowired
	public UserService(UserDao userDao) {
		System.out.println("UserService :: 1-Param Constructor");
		this.userDao = userDao;
	}
}
---------------------------------------------------------------------------------
Today's session : Setter Injection
---------------------------------------------------------------------------------
-> The process of injecting dependent bean object into target bean object through target class setter method is called as Setter Injection.

-> To inform IOC to perform Setter Injection we will write @Autowired annotation at target class setter method.

-> In Setter Injection target bean object will be created first then dependent bean object will be created.

----------------------------------------------------------------------------------
package in.ashokit.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import in.ashokit.dao.UserDao;
import in.ashokit.util.EmailUtils;
import in.ashokit.util.PwdUtils;

@Service
public class UserService {

	private PwdUtils pwdUtils;

	private EmailUtils emailUtils;

	private UserDao userDao;

	public UserService() {
		System.out.println("UserService::Constructor");
	}

	@Autowired
	public void setPwdUtils(PwdUtils pwdUtils) {
		this.pwdUtils = pwdUtils;
	}

	@Autowired
	public void setEmailUtils(EmailUtils emailUtils) {
		this.emailUtils = emailUtils;
	}

	@Autowired
	public void setUserDao(UserDao userDao) {
		this.userDao = userDao;
	}

	public void registerUser() {
		pwdUtils.encryptPwd();
		userDao.save();
		emailUtils.sendEmail();
		System.out.println("User Record Saved....");
	}

}
------------------------------------------------------------------------------------------------------------------------------------------------------------------     