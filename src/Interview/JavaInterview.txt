Interview Questions

ðŸ”µ What are JDK, JRE, and JVM?
    - JDK contains set of tools to develop java programs
    - JRE providing a platform to run our java programs
    - JVM will take care of program execution, memory allocation & de-allocation
ðŸ”µ Explain Abstraction and Encapsulation?

ðŸ”µ What is Inheritance, Aggregation, and Association?

ðŸ”µ What is a try-with-resource in Java?
    The try-with-resources statement is a try statement that declares one or more resources.
    the try-with-resources statement is a mechanism that automatically closes resources (like files, network connections, etc.)
    when they are no longer needed. This feature was introduced in Java 7 to make resource management more efficient and less error-prone.
    It ensures that each resource is closed at the end of the statement, even if an exception is thrown, thus preventing resource leaks.

ðŸ”µ Explain different Java 8 features?

ðŸ”µ Why is String immutable in Java?

ðŸ”µ Explain the JVM memory model?

ðŸ”µ Explain Garbage Collection?

ðŸ”µ What are exceptions and what is exception handling?

ðŸ”µ Explain Autoboxing and Unboxing?

ðŸ”µ What is Typecasting? Explain with Parent-Child inheritance example.

ðŸ”µ Why is the Java platform independent?

ðŸ”µ How many ways can we create objects in Java?
    Using the new keyword
    Using Reflection: Class.getDeclaredConstructor().newInstance()
    Using the clone() method
    Using Factory Methods
    Using Deserialization
    Using Class.newInstance() (Deprecated)
    Using Constructor.newInstance()
    Using Dependency Injection Frameworks
ðŸ”µ What is the Collections framework?

ðŸ”µ Explain static, this, and super keyword?

ðŸ”µ Explain finally, finalize and final keyword?

Advanced:

ðŸ”µ What is Serialization?
    Serialization in Java is the process of converting an object into a byte stream, thereby making it possible to save the object to a file,
    send it over a network, or store it in a database. This byte stream can later be deserialized back into a copy of the original object.
    Serialization is fundamental for various operations, including saving the state of an object, deep cloning, and distributing objects across different JVMs.
ðŸ”µ Explain the Internal working of a HashMap?

ðŸ”µ What is Concurrent HashMap?
    ConcurrentHashMap is a thread-safe variant of HashMap introduced in Java 1.5 under the java.util.concurrent package.
     It is designed to handle concurrent operations more efficiently and allows safe, high-performance,
     and scalable access by multiple threads.

ðŸ”µ Difference between ArrayList and LinkedList.
    ArrayList
    Data Structure: Dynamic array
    Access Time: O(1) for direct access by index
    Insertion/Deletion: O(n) for insertions and deletions not at the end
    Memory Usage: Lower memory overhead
    Iteration: Faster due to better cache locality
    Random Access: Fast (O(1))
    Use Case: Preferred for frequent read operations and append operations at the end
    LinkedList
    Data Structure: Doubly linked list
    Access Time: O(n) for access by index
    Insertion/Deletion: O(1) for insertions and deletions with a known node reference
    Memory Usage: Higher memory overhead per element
    Iteration: Slower due to poor cache locality
    Random Access: Slow (O(n))
    Use Case: Preferred for frequent insertions and deletions at the beginning or middle
|
ðŸ”µ Difference between Comparator and Comparable.

    Comparable is an interface in Java vs	Comparator is a functional interface in Java.
    Comparable provides compareTo() method to sort objects.	vs Comparator provides compare() method to sort objects.
    Comparable is a part of the Java.lang package.	vs Comparator is a part of the java.util package.
    Comparable can be used for natural or default ordering. vs	Comparator can be used for custom ordering.
    Comparable provides a single sorting sequence. Ex: Sort either by id or name	vs Comparator provides multiple sorting sequences. Ex. Sort by both id and name.
    Comparable modifies the class that implements it.	vs Comparator doesn't modify any class.

ðŸ”µ What is the default size of ArrayList and HashMap?
    ArrayList: Default initial capacity is 10.
    HashMap: Default initial capacity is 16, with a default load factor of 0.75.

ðŸ”µ What are Marker Interfaces and Functional Interfaces?
    Marker Interfaces:

    Interfaces with no methods or fields.
    Used to indicate that a class possesses a specific property.
    Examples: Serializable, Cloneable.
    Functional Interfaces:

    Interfaces with exactly one abstract method.
    Used to represent single actions or functions.
    Central to functional programming in Java.
    Examples: Runnable, Callable, Comparator, Predicate.
ðŸ”µ Explain Classloading in java and types of classloaders?
    Classloading in Java is the process of loading Java classes into memory.
    Bootstrap ClassLoader: Loads core Java classes.
    Extension (Platform) ClassLoader: Loads classes from the Java extensions directory.
    System (Application) ClassLoader: Loads classes from the system classpath.
    Custom ClassLoader: User-defined classloader for custom class loading strategies.
    Classloading follows a delegation model, ensuring a consistent and secure classloading process.
ðŸ”µ What are Generics in Java?
    Generics in Java provide a powerful tool for writing flexible and type-safe code. By using generics,
     you can create classes, methods, and collections that work with any data type,
     while ensuring type safety and reducing the need for type casting. This leads to more robust and maintainable code.
ðŸ”µ How can we create a custom Exception?
    // Define the custom checked exception
    public class InvalidAgeException extends Exception {

        // Constructor that accepts a message
        public InvalidAgeException(String message) {
            super(message);
        }
    }

    // Main class to demonstrate the usage of the custom exception
    public class Main {
        public static void main(String[] args) {
            try {
                validateAge(15); // This will throw an InvalidAgeException
            } catch (InvalidAgeException e) {
                System.out.println("Caught an InvalidAgeException: " + e.getMessage());
            }
        }

        // Method to validate age, throws InvalidAgeException if age is less than 18
        public static void validateAge(int age) throws InvalidAgeException {
            if (age < 18) {
                throw new InvalidAgeException("Age must be 18 or older.");
            }
            System.out.println("Age is valid.");
        }
    }

ðŸ”µ What is the Covariant return type?
   Covariant return type means return type may vary during overriding
   Before java5 it was not allowed to override any method if return type is changed in child class
   But now its possible only if return type is subclass type

   class Animal {
       public Animal getAnimal() {
           return new Animal();
       }
   }

   class Dog extends Animal {
       @Override
       public Dog getAnimal() {
           return new Dog(); // Covariant return type
       }
   }

   public class Main {
       public static void main(String[] args) {
           Dog dog = new Dog();
           Dog dog2 = dog.getAnimal();
           System.out.println("dog2 is of type: " + dog2.getClass().getName());
       }
   }

ðŸ”µ What is Threading?

ðŸ”µ What are Daemon threads?
    Daemon threads are a type of thread in Java that run in the background to perform tasks such as garbage collection,
    memory management, or other system housekeeping activities. They are distinguished from user threads by the fact that the JVM does not wait for daemon threads to finish before exiting.
ðŸ”µ Difference between start() and run() ?
    start() is used to initiate the execution of a thread,
    which then invokes the run() method in a separate thread context. run() is the method where you define the task that you want the thread to perform.
ðŸ”µ What is the Volatile keyword?
    Volatile keyword is used to modify the value of a variable by different threads.
     It is also used to make classes thread safe. It means that multiple threads can use a method and instance of the classes at the same time without any problem.
ðŸ”µ Difference between Synchronized method and block?
    A synchronized method uses the method receiver as a lock (i.e. this for non static methods, and the enclosing class for static methods).
    Synchronized blocks uses the expression as a lock.
    Scope: Synchronized methods synchronize the entire method, whereas synchronized blocks allow you to synchronize specific sections of code using a designated lock object.
    When to Use Which:
    Synchronized Method: Use when you want to synchronize the entire method and the synchronization context is tied to the object instance or the class itself (for static methods).

    Synchronized Block: Use when you need to synchronize specific critical sections of code within a method, or when you want to use a specific lock object for synchronization, offering more fine-grained control.
ðŸ”µ Difference between sleep(), wait (), yield()?

ðŸ”µ Difference between sleep(), wait (), yield()?

Spring Boot
Spring Boot Basic Interview Questions - Part 1

1) What are the key Components of Spring Boot
2) Why Spring Boot over Spring?
3) What does @SpringBootApplication annotation do?
4) What is Spring Initializer?
5) Basic annotations used in Spring Boot
6) Tomcat server in Spring Boot
    Dependencies: Include spring-boot-starter-web dependency in your project to automatically embed Tomcat as the servlet container.

    Configuration: No additional configuration is typically needed as Spring Boot auto-configures the embedded Tomcat server.

    Starting the Application: Run your Spring Boot application using Maven (mvn spring-boot:run) or Gradle (gradle bootRun), and Tomcat starts automatically.

    Customization (Optional): Customize Tomcat's configuration (e.g., port, SSL) using WebServerFactoryCustomizer beans in your configuration class.
7) What is @RestController annotation in Spring boot, and how it differs from @controller?
    @RestController is a convenient shortcut that combines @Controller and @ResponseBody annotations.
    Use @Controller for traditional MVC controllers that render views.
    Use @RestController for creating RESTful APIs that return data directly in JSON or XML format.
8) What is the difference between RequestMapping and GetMapping?
9) What is Spring Actuator? What are its advantages?
10) What is dependency Injection?


The key features and aspects of the Spring Framework:

1) Frameworks and itâ€™s types.

2)Understanding Modules of Spring Architecture.

3)Inversion of Control (IoC)

4)Dependency Injection.

5) Container.

6) Resources to Develop a Spring Application.

7)BeanFactory Container.

8)ApplicationContext Container.

9) @Autowired Annotation.

10) @Qualifier Annotation.

11) Spring Bean Scopes- Understanding Singleton Java Class.

12) Spring Bean Life-Cycle.

13) Inner Bean Concept.

14) Lazy init attribute.

15)Multiple no. Of Configuration Files in Spring Applications.

16) Spring Annotations.