In Java, a thread is a separate flow of execution that can run concurrently with other threads.
 Threads are used to improve the performance and efficiency of a program by allowing multiple tasks to run in parallel.

The thread is a subset of process. The process can contain multiple threads.
The process can run on on different memory space, but all threads share the same memory space.
There are two types of threads in Java. They are,

User Threads
Daemon Threads

1. Thread Class: The Thread class is the foundation of concurrency in Java. It provides methods for creating and managing threads.
2. Runnable Interface: The Runnable interface is used to define a task that can be executed by a thread.
3. Thread Creation
   1.Extending the Thread class:

   -Create a new class that extends Thread.
   -Override the run() method.
   -Create an instance of the new class and call the start() method.
       class MyThread extends Thread {
           public void run() {
               System.out.println("Thread is running.");
           }
       }

       public class TestThread {
           public static void main(String[] args) {
               MyThread t1 = new MyThread();
               t1.start();
           }
       }
   2.Implementing the Runnable interface:

   -Create a class that implements Runnable.
   -Implement the run() method.
   -Create an instance of Thread class, passing the Runnable instance to its constructor.
   -Call the start() method on the Thread instance.
       class MyRunnable implements Runnable {
           public void run() {
               System.out.println("Thread is running.");
           }
       }

       public class TestRunnable {
           public static void main(String[] args) {
               Thread t1 = new Thread(new MyRunnable());
               t1.start();
           }
       }
4. Thread Life Cycle: A thread goes through several states during its life cycle:
    - Newborn: The thread is created but not started.
    - Runnable: The thread is ready to run but not running.
    - Running: The thread is executing.
    - Blocked: The thread is waiting for a resource or lock.
    - Dead: The thread has completed execution.
5. Thread Methods
   - start(): Starts the thread.
   - run(): Contains the code to be executed by the thread.
   - join(): Waits for the thread to complete.
   - sleep(): Pauses the thread for a specified time.
   - yield(): Temporarily relinquishes the thread's execution.
   - interrupt(): Interrupts the thread's execution.
6. Synchronization: Ensures that multiple threads can access shared resources without conflicts.
   Java provides various synchronization mechanisms, such as:
   - Synchronized methods and blocks: Use the synchronized keyword to protect shared data.
   - Locks (e.g., ReentrantLock): Use locks to protect shared data.
   - Atomic variables: Use atomic variables to update shared data.
   - Concurrent collections (e.g., CopyOnWriteArrayList): Use concurrent collections to access shared data.
7. Thread Communication

- wait() and notify(): Use wait() to pause a thread and notify() to resume it.
- notifyAll(): Notifies all waiting threads.
- Condition variables (e.g., Await and Signal): Use condition variables to communicate between threads.

8. Thread Safety

- Atomic operations (e.g., AtomicInteger): Use atomic operations to update shared data.
- Volatile variables: Use volatile variables to ensure visibility of shared data.
- Immutable objects: Use immutable objects to ensure thread safety.

9. Thread Pools

- Executor framework: Use the executor framework to manage threads.
- ThreadPoolExecutor: Use ThreadPoolExecutor to manage threads.
- ScheduledThreadPoolExecutor: Use ScheduledThreadPoolExecutor to schedule tasks.

10. Thread-Local Variables

- ThreadLocal class: Use ThreadLocal to create thread-local variables.
- InheritableThreadLocal class: Use InheritableThreadLocal to create inheritable thread-local variables.

11. Thread Group

- ThreadGroup class: Use ThreadGroup to group threads.
- Thread group membership: Use ThreadGroup to manage thread membership.

12. Daemon Threads

- Daemon threads vs. user threads: Understand the difference between daemon and user threads.
- Setting a thread as a daemon: Use setDaemon(true) to set a thread as a daemon.

13. Thread Priority

- Thread priority levels (MIN_PRIORITY to MAX_PRIORITY): Understand the thread priority levels.
- Setting a thread's priority: Use setPriority() to set a thread's priority.


14. Thread Interruption

- Interrupting a thread: Use interrupt() to interrupt a thread.
- Handling interruptions (e.g., InterruptedException): Handle interruptions properly.

15. Deadlocks
Deadlock is a situation when a thread is waiting for an object lock,
that is acquired by another thread and second thread also waiting for an object lock that is acquired by the first thread.
 As both threads are waiting for each other to release this condition is called deadlock.


- Causes of deadlocks: Understand the causes of deadlocks.
- Avoiding deadlocks: Use synchronization and communication to avoid deadlocks.

16. Starvation and Livelocks

- Starvation (thread starvation): Understand thread starvation.
 when a thread does not have sufficient CPU for its execution Thread starvation happens.
- Livelocks (thread livelock): Understand thread livelock.
Livelock occurs when all threads are blocked and not able to execute because of the unavailability of required resources,
and non-existence of any unblocked thread.


Some best practices for working with threads in Java include:

- Use threads for tasks that can run concurrently.
- Use synchronization to protect shared data.
- Avoid using stop() and suspend() methods, as they are deprecated.
- Use interrupt() to interrupt a thread.