
Today's session : Microservices
--------------------------------------------------------------------------------
-> Now a days java is mainley using to develop web applications only

-> We can develop web applications in 2 ways

		1) Monolith Architecture
		2) Microservices Architecture

---------------------------------------------------------------------------------
What is Monolith Architecture?
---------------------------------------------------------------------------------
-> If we develop all the functionalities in one single application then we will call it as Monolith Architecture based application.

-> When we package our application we will get one war file.

-> Monolith application war files are called as fat war files or heavy weight war files

-> It is very difficult to manage and maintain fat war files


Advantages
----------
1) Implementation will be easy

2) Bug Tracking/Debugging Will be easy

3) Better throughput


Dis-Advantages
---------------
1) Tighthly coupling among the components

2) Less Scalability

3) Burden on server

4) Deployment process will be difficult

5) Load Balancing is difficult & challenging
----------------------------------------------------------------------------------

-> To avoid the problems of Monolith Architecture, Microservices Architecture Came into picture.

----------------------------------------------------------------------------------
What is Microservices ?
----------------------------------------------------------------------------------
-> Microservices is not a programming language

-> Microservices is not a technology

-> Microservices is not a framework

-> Microservies is not an API

-> Microservices is a design pattern which is used to develop our application functionalities with loosely coupling.

-> Microservices architecture is not specific to any technology. 

----------------------------------------------------------------------------------
Challenges with Microservices
----------------------------------------------------------------------------------
1) Bounded Context

2) Boiler Plate Configuration

3) Visibility

4) Pack of cards problem
----------------------------------------------------------------------------------
-> Bounded Context means deciding boundary for rest api is very difficult. How many rest apis we need to develop for given requirements ? deciding this is difficult task.

-> In every REST api we have to write same configurations

		1) DB Config
		2) Security Config
		3) Actuator Config
		4) Redis Config
		5) Kafka Config

-> All the developers will not have visibility on all the apis available in project.

-> Pack of cards problem means if any important microservice failed then request can't be processed.
----------------------------------------------------------------------------------
Advantages of Working with Microservices
---------------------------------------------------------------------------------
1) Easy Maintenence

2) Scalability

3) Technology Independence

4) Easy Deployment
----------------------------------------------------------------------------------
Microservices Architecture
----------------------------------------------------------------------------------
-> There is no fixed architecture for Microservices development

-> People are customizing microservices architecture as per their requirement.

Note-1 : We will discuss about generalized architecture for Microservices development which is using by most of the projects in the industry.

Note-2: In one company 2 different projects might use 2 different approaches to develop Microservices based applications.

-----------------------------------------------------------------------------------

Last Session : Microservices Architecture
---------------------------------------------------------------------------------
-> Microservices is a design pattern which is used to develop the applications with loosely coupling.

-> Microservices is not specific to any technology.

-> We don't have any fixed architecture for Microservices.

-> People are customizing microservices architecture as per their requirement.
---------------------------------------------------------------------------------
Service Registry
---------------------------------------------------------------------------------
-> Service Registry is used to register all the services(apis) availablein application.

-> We can use Eureka Server as Service Registry for our apis.

-> Spring Cloud Netflix libraries provided Eureka Server for us.

Steps to develop Service Registry Application
----------------------------------------------
-> Create Spring Starter Project with below dependencies

	1) spring-cloud-starter-netflix-eureka-server
	2) spring-boot-devtools

-> Enable Eureka Server in boot start class using @EnableEurekaServer annotation

-> Configure below properties in application.yml file

server:
   port: 8761
eureka:
  client:
    register-with-eureka: false

-> Start the application and access Eureka dashboard using below URL

		http://localhost:8761/

-------------------------------------------------------------------------------------

Last Session : What is Service Registry ?
----------------------------------------------------------------------------------
-> Service Registry is an API which is used to register all the apis available in our application.

-> If we register our apis with service registry then we can monitor all our apis and apis details at one place.

-> Eureka Server we can use as Service Registry for our Microservices architecture based application.

-> Spring Cloud Netflix Libraries provided Eureka Server for us

-> To enable Eureka Server in our application we will use @EnableEurekaServer annotation

---------------------------------------------------------------------------------

-> In our application we will develop several APIs

-> API is also called as Service

-> The API which is registered with Eureka Server is called as Eureka Client or Discovery Client

-> To represent our API as Eureka client application we will use @EnableDiscoveryClient annotation

-> If Eureka Server is running on same machine with 8761 port then our API will auto-register with Eureka Server.

-> If we want to register our api with Eureka Server manually then we need to configure below property in application.yml file

eureka:
  client:
    service-url:
      defaultZone: ${DISCOVERY_URL:http://localhost:9090}/eureka/


-> We will configure name for our API using below property

spring:
  application:
    name: GREET-API

Note: This name will be displayed in Eureka Dashboard once our API got registered with Eureka Server.
----------------------------------------------------------------------------------
-> What is Interservice Communication ?
---------------------------------------------------------------------------------

-> If one API is communicating with another api which are belongs to same application then it is called as Inter service communication.
----------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------

-> In Microservices Architecture based application, we will develop several REST apis.

-> As part of application execution, one rest api will communicate with another rest api. This is called as Interservice Communication.

-> To achieve Interservice Communication we can use FeginClient.

-> FeginClient provided by Spring Cloud Netflix library.

----------------------------------------------------------------------------------

1) Add Feign client dependency in pom.xml file

2) Write @EnableFeignClients dependency at boot start class

3) Creat Fegin Client component like below to access other api

-------------------------------------------------------------------------------
@FeignClient(name = "GREET-API")
public interface GreetClient {

	@GetMapping("/greet")
	public String invokeGreetApi();

}
----------------------------------------------------------------------------------
-> GREET-API is name of the api which is registered in Eureka Server

-> @GetMapping("/greet) representing that GREET-API having endpoint method with GET request and url-pattern is "/greet".

-> When we call invokeGreetApi() method, FeignClient will get GREET-API url from service registry based on name then it will call GREET-API and will get the response.
----------------------------------------------------------------------------------
Last session : FeignClient & Interservice Communication
-------------------------------------------------------------------------

-> In one project we will develop multiple services

-> If one service wants to communicate with another service in same project then we will call it as Interservice Communication.

-> To achieve Interservice Communication we will use FeignClient.

-> FeignClient will get service url from service registry based on service name.
---------------------------------------------------------------------------------
API Gateway
---------------------------------------------------------------------------------
-> API Gateways acts as single entry point for all the backednd apis available in the application.

-> API Gateway is used to manage all the apis available in the application.

-> We can use Zuul Proxy as API Gateway

-> Zuul Proxy provided by Spring Cloud Netflix Library
Last session : API Gateway with Example
---------------------------------------------------------------------------------
Today's session : Mini Project Requirement
---------------------------------------------------------------------------------------------
-> What is Service Registry ?

-> What is Eureka Client ?

-> How to register our API with Eureka Server ?

-> What is Interservice Communication ?

-> What is FeignClient?

-> What is API Gateway ?

-> How to configure Routing in API Gateway ?
----------------------------------------------------------------------------------------------
-> We can pass Embedded Server PORT number as an VM argument

-> Right Click On Project -> Run As -> Run Configurations -> Arguments -> VM Arguments

		-Dserver.port=1111
-------------------------------------------------------------------------------------------
->  We can get server port number using Environment Object
-------------------------------------------------------------------------------------------
package in.ashokit.rest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class WelcomeRestController {

	@Autowired
	private Environment env;

	@GetMapping("/welcome")
	public String welcomeMsg() {
		String port = env.getProperty("server.port");
		String msg = "Welcome to Ashok IT..!!" + " Server Running On :: " + port;
		return msg;
	}
}
----------------------------------------------------------------------------------------------
Mini Project Introduction
----------------------------------------------------------------------------------------------

STOCK-PRICE-API : This api will maintain company stock prices in db table. This api will take company name as input and it will provide company stock price as output.

STOCK-CALC-API : This api is used to calculate total stocks cost based on quantity. This api will take company_name & quantity as input and it will return total_cost as output.

Note: STOCK-CALC-API will get stock_price from STOCK-PRICE-API based on company_name.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Today's session : Load Balancing
---------------------------------------------------------------------------------
-> Load Balancing is the process of distributing load from one server to multiple servers.

-> If we deploy our application in one server then it is responsible to handle all incoming requests.

-> If all requests are going to single server then burden will increase on the server.

-> If burden increased on server then we will see below issues

		1) Response Delay

		2) Server Crash etc..

-> To avoid these problems we will deploy our application using Load Balancer.

-> Load Balancing we can implement in 2 ways

		1) Server Side Load Balancing

		2) Client Side Load Balancing
-------------------------------------------------------------------------------------------------------------------
-> To implement Server Side balancing Load Balancer algorithm will be configured to decide which request should be processed by which server.

			i) Round Robbin
			ii) Sticky Session
			iii) Ip Hashing

Q) What is scale up?
Q) What is scale down?

-> Adding more servers to LBR based on demand is called as Scale up.

-> Removing servers from LBR is called as Scaled down.

-> Adding servers and removing servers manually is time taking process.

-> Now a days we are using Auto-Scaling.

Q) What is Auto Scaling?
-> It is the process of adding and removing servers from LBR based on demand.

Ex: Amazon BigDay sale, Flipkart BigDay Sale etc..

-> Companies can't guess traffic on Big Day sale thats why they will prefer AutoScaling.
---------------------------------------------------------------------------------







1) Spring Boot Admin Server & Client
2) Distributed Logging (Slueth & Zipkin)
3) Circuit Breaker
4) Connecting with Multiple Databases
5) Securing Rest APIs
6) Apache Kafka
7) Redis Cache
8) Angular Integration
9) Docker
10) Profiles in Spring Boot (Video)
11) Exception Handling in Rest API (Video)
-----------------------------------------------------------------------------

---------------------------------------------------------------------------------
Spring Boot Admin Server & Admin Client
---------------------------------------------------------------------------------
-> Spring Boot provided actuators to get production ready features

-> Spring boot actuators having below endpoints

		- info
		- health
		- beans
		- mappings
		- env
		- shutdown
		- threaddump
		- heapdump
		- httpTrace etc.

-> To work with actuators we have to add below starter in pom.xml file

		1)spring-boot-starter-actuator

-> To expose actuator endpoints we will write below configuration

	management.endpoints.web.exposure.include= '*'

-> To see exposed endpoints of our application we can use below url

		http://localhost:portnumber/actuator/

-> Admin Server is providing user interface to monitor all the registered services at one place using actutor endpoints.

---------------------------------------------------------------------------------
Steps to develop admin server project
--------------------------------------------------------------------------------
1) Create Spring Boot application with Admin-server dependency

	<dependency>
		<groupId>de.codecentric</groupId>
		<artifactId>spring-boot-admin-starter-server</artifactId>
	</dependency>

2) Write below annotation at Spring Boot start class

@SpringBootApplication
@EnableAdminServer
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}

3) Configure port number

4) Run the application and access admin-server-dashboard

------------------------------------------------------------------------------------------
Steps to develop Admin Client Application
-------------------------------------------------------------------------------------------
1) Create Spring Boot Application with below dependencies

		i)starter-web
		ii)actuator
		iii)admin-client
		iv) devtools

<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>de.codecentric</groupId>
			<artifactId>spring-boot-admin-starter-client</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>

2) Configure below properties in application.yml file
	
		i)server-port
		ii) application-name
		iii) actuator-props
		iv) admin-server-app-url

server:
  port: 2222
spring:
  application:
    name: CLIENT-TWO
  boot:
    admin:
      client:
        url: http://localhost:9090/
management:
  endpoints:
    web:
      exposure:
        include: '*'

3) Create Rest Controller with Required Methods

4) Run the application and verify Admin-Server-Dashboard

--------------------------------------------------------------------------------------------
Distributed Logging (Using Sleuth & Zipkin)
-----------------------------------------------------------------------------------------

-> Download Zipkin Server (it is a jar file)

-> Run Zipkin server using below command

	java -jar  zipkin-server.jar

Note: Zipkin server will run on the port number 9411 (http://localhost:9411)

-> Create Spring Boot application with below dependencies

<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-sleuth</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-zipkin</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>

-> Configure server-port and application-name in yml file

-> Create Rest Controller with Required methods

-> Run the application and test it.

Note: Application execution log details can be monitored in zipkin server dashboard.

Note: Now a days in the industry we are using Splunk for this.
---------------------------------------------------------------------------------------------























































































































